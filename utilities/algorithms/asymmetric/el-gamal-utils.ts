import { getTimestamp } from '../../time/timestamp-utils';
import { modularExponentiation } from '../../math/modular-exponentiation-utils';

export function encrypt({
  plainText,
  y,
  g,
  p,
  k,
}: {
  plainText: string;
  y: number;
  g: number;
  p: number;
  k: number;
}): string {
  const result: string[] = [];

  for (const char of plainText) {
    const m = char.charCodeAt(0);
    const a = modularExponentiation(g, k, p);
    const b = (modularExponentiation(y, k, p) * m) % p;
    result.push(`(${a},${b})`);
  }

  return result.join(' ');
}

export function decrypt({
  plainText,
  x,
  p,
}: {
  plainText: string;
  x: number;
  p: number;
}): string {
  const pairs = plainText.match(/\((\d+),(\d+)\)/g);
  if (!pairs) return '';

  let result = '';

  for (const pair of pairs) {
    const [a, b] = pair
      .replace(/[()]/g, '')
      .split(',')
      .map((v) => parseInt(v, 10));

    const aToPX = modularExponentiation(a, p - 1 - x, p);
    const m = ((b * aToPX) % p);
    result += String.fromCharCode(m);
  }

  return result;
}

export function generateSteps({
  text,
  y,
  g,
  p,
  k,
  isDecrypt,
  x,
}: {
  text: string;
  y?: number;
  g?: number;
  p: number;
  k?: number;
  x?: number;
  isDecrypt: boolean;
}): string {
  const steps: string[] = [];

  if (isDecrypt) {
    const pairs = text.match(/\((\d+),(\d+)\)/g);
    if (!pairs || !x) return '';

    for (const pair of pairs) {
      const [a, b] = pair
        .replace(/[()]/g, '')
        .split(',')
        .map((v) => parseInt(v, 10));

      const aToPX = modularExponentiation(a, p - 1 - x, p);
      const m = ((b * aToPX) % p);
      steps.push(
        `a = ${a}, b = ${b}\n` +
        `a^x mod p = ${aToPX}\n` +
        `m = (b * a^(-x)) mod p = (${b} * ${aToPX}) mod ${p} = ${m} = '${String.fromCharCode(m)}'\n`
      );
    }
  } else {
    if (!g || !y || !k) return '';

    for (const char of text) {
      const m = char.charCodeAt(0);
      const a = modularExponentiation(g, k, p);
      const b = (modularExponentiation(y, k, p) * m) % p;

      steps.push(
        `char = '${char}' (ASCII ${m})\n` +
        `a = g^k mod p = ${g}^${k} mod ${p} = ${a}\n` +
        `b = y^k * m mod p = ${y}^${k} * ${m} mod ${p} = ${b}\n` +
        `cipher = (${a},${b})\n`
      );
    }
  }

  return steps.join('\n');
}

export function downloadResult({
  mode,
  plainText,
  cipherText,
  params,
}: {
  mode: 'encrypt' | 'decrypt';
  plainText: string;
  cipherText: string;
  params: Record<string, number>;
}) {
  const now = new Date();
  const timestamp = now.toLocaleString('en-EN', {
    dateStyle: 'full',
    timeStyle: 'long',
  });

  const header = mode === 'decrypt' ? 'DECRYPTION' : 'ENCRYPTION';
  const inputLabel = mode === 'decrypt' ? '>>> CIPHER TEXT' : '>>>> PLAIN TEXT';
  const outputLabel = mode === 'decrypt' ? '>>>> PLAIN TEXT' : '>>> CIPHER TEXT';
  const inputText = plainText;
  const outputText = cipherText;

  const paramList = Object.entries(params)
    .map(([k, v]) => `  ${k} = ${v}`)
    .join('\n');

  const content = `
=============== EL-GAMAL ${header} RESULT ===============
Time       : ${timestamp}
Parameters :
${paramList}
----------------------------------------------------------

${inputLabel}:

${inputText}

${outputLabel}:

${outputText}

==========================================================
Generated by Cryptography & Network Security
Made with ❤️ by AlicelieseLou
`.trim();

  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `el-gamal-${header.toLowerCase()}-${getTimestamp()}.txt`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
